# Разделение генерации RPC кода между клиентом и сервером

## Введение

Необходимо разделить генерацию RPC кода так, чтобы клиент получал только Dispatcher (для обработки входящих RPC), а сервер получал только Sender (для отправки RPC). Это повысит безопасность и уменьшит размер сборок.

## Требования

### Требование 1: Разделение генерации для сервера

**Пользовательская история:** Как разработчик сервера, я хочу иметь доступ только к RPC отправителям, чтобы сервер не содержал код обработки RPC и был более безопасным.

#### Критерии приемки
1. КОГДА генератор запускается в серверном проекте, ТО он ДОЛЖЕН генерировать только Sender классы
2. КОГДА генератор запускается в серверном проекте, ТО он НЕ ДОЛЖЕН генерировать Dispatcher классы
3. КОГДА сервер компилируется, ТО в нем НЕ ДОЛЖНО быть кода для обработки входящих RPC
4. КОГДА сервер использует RPC, ТО он ДОЛЖЕН иметь доступ к методам отправки TargetRpc и ClientRpc

### Требование 2: Разделение генерации для клиента

**Пользовательская история:** Как разработчик клиента, я хочу иметь доступ только к RPC диспетчерам, чтобы клиент не содержал код отправки RPC и был более безопасным.

#### Критерии приемки
1. КОГДА генератор запускается в клиентском проекте, ТО он ДОЛЖЕН генерировать только Dispatcher классы
2. КОГДА генератор запускается в клиентском проекте, ТО он НЕ ДОЛЖЕН генерировать Sender классы
3. КОГДА клиент компилируется, ТО в нем НЕ ДОЛЖНО быть кода для отправки RPC
4. КОГДА клиент получает RPC, ТО он ДОЛЖЕН иметь доступ к диспетчерам для обработки TargetRpc и ClientRpc

### Требование 3: Автоматическое определение типа проекта

**Пользовательская история:** Как разработчик, я хочу чтобы генератор автоматически определял тип проекта, чтобы не настраивать генерацию вручную.

#### Критерии приемки
1. КОГДА генератор запускается в проекте с именем содержащим "Server", ТО он ДОЛЖЕН генерировать только Sender код
2. КОГДА генератор запускается в проекте с именем содержащим "Client", ТО он ДОЛЖЕН генерировать только Dispatcher код
3. КОГДА генератор запускается в проекте с именем содержащим "Shared", ТО он НЕ ДОЛЖЕН генерировать RPC код
4. ЕСЛИ тип проекта не может быть определен автоматически, ТО генератор ДОЛЖЕН выдать предупреждение

### Требование 4: Совместимость с существующим CommandIdManager

**Пользовательская история:** Как разработчик, я хочу чтобы разделенная генерация использовала тот же CommandIdManager, чтобы ID команд оставались синхронизированными.

#### Критерии приемки
1. КОГДА генератор создает Sender код, ТО он ДОЛЖЕН использовать CommandIdManager для получения ID
2. КОГДА генератор создает Dispatcher код, ТО он ДОЛЖЕН использовать те же ID что и Sender
3. КОГДА оба генератора работают в одной компиляции, ТО ID команд ДОЛЖНЫ быть синхронизированы
4. КОГДА добавляется новая RPC команда, ТО она ДОЛЖНА получить уникальный ID через CommandIdManager

### Требование 5: Генерация отдельных файлов

**Пользовательская история:** Как разработчик, я хочу чтобы Sender и Dispatcher генерировались в отдельные файлы, чтобы было легче отлаживать и понимать код.

#### Критерии приемки
1. КОГДА генератор создает Sender код, ТО он ДОЛЖЕН создать файл "TargetClientRpcSender.g.cs"
2. КОГДА генератор создает Dispatcher код, ТО он ДОЛЖЕН создать файл "TargetClientRpcDispatcher.g.cs"
3. КОГДА генерируются файлы, ТО они ДОЛЖНЫ содержать соответствующие namespace для проекта
4. КОГДА файлы генерируются, ТО они ДОЛЖНЫ содержать комментарий "// <auto-generated/>"

### Требование 6: Правильные namespace для проектов

**Пользовательская история:** Как разработчик, я хочу чтобы сгенерированный код использовал правильные namespace, чтобы избежать конфликтов имен.

#### Критерии приемки
1. КОГДА генератор создает Sender код, ТО он ДОЛЖЕН использовать namespace "KarpikEngineServer.Generated"
2. КОГДА генератор создает Dispatcher код, ТО он ДОЛЖЕН использовать namespace "KarpikEngineClient.Generated"
3. КОГДА код генерируется, ТО он ДОЛЖЕН импортировать необходимые using директивы
4. КОГДА код используется, ТО не ДОЛЖНО быть конфликтов namespace между проектами

### Требование 7: Обратная совместимость

**Пользовательская история:** Как разработчик, я хочу чтобы новая система была обратно совместима с существующим кодом, чтобы не ломать текущую функциональность.

#### Критерии приемки
1. КОГДА новый генератор запускается, ТО существующие RPC команды ДОЛЖНЫ продолжать работать
2. КОГДА используется новый генератор, ТО API для отправки RPC НЕ ДОЛЖНО измениться
3. КОГДА используется новый генератор, ТО API для обработки RPC НЕ ДОЛЖНО измениться
4. КОГДА происходит миграция, ТО старый генератор ДОЛЖЕН быть отключен без ошибок

## Ограничения

- Генератор должен работать только с существующими интерфейсами ITargetRpcCommand и IClientRpcCommand
- Изменения не должны затрагивать существующую архитектуру ECS
- Генератор должен поддерживать все существующие типы данных для сериализации
- Производительность генерации не должна ухудшиться

## Критерии успеха

- Сервер содержит только код отправки RPC
- Клиент содержит только код обработки RPC  
- ID команд синхронизированы между проектами
- Размер сборок уменьшен за счет исключения ненужного кода
- Безопасность повышена за счет разделения ответственности