# Дизайн разделения RPC генерации

## Архитектурный обзор

Текущий `TargetClientRpcGenerator` генерирует и Sender и Dispatcher код в одном файле. Необходимо разделить его на два отдельных генератора или добавить логику условной генерации.

## Компоненты системы

### 1. ProjectTypeDetector
Утилитарный класс для определения типа проекта:

```csharp
internal static class ProjectTypeDetector
{
    public enum ProjectType
    {
        Server,
        Client,
        Shared,
        Unknown
    }
    
    public static ProjectType DetectProjectType(string assemblyName)
    {
        if (assemblyName.Contains("Server", StringComparison.OrdinalIgnoreCase))
            return ProjectType.Server;
        if (assemblyName.Contains("Client", StringComparison.OrdinalIgnoreCase))
            return ProjectType.Client;
        if (assemblyName.Contains("Shared", StringComparison.OrdinalIgnoreCase))
            return ProjectType.Shared;
        return ProjectType.Unknown;
    }
}
```

### 2. Модифицированный TargetClientRpcGenerator
Основной генератор с условной логикой:

```csharp
private void Execute(SourceProductionContext context, Compilation compilation)
{
    var projectType = ProjectTypeDetector.DetectProjectType(compilation.AssemblyName);
    
    switch (projectType)
    {
        case ProjectType.Server:
            GenerateServerCode(context, compilation);
            break;
        case ProjectType.Client:
            GenerateClientCode(context, compilation);
            break;
        case ProjectType.Shared:
            // Не генерируем RPC код в Shared проекте
            return;
        case ProjectType.Unknown:
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("RPC001", "Unknown project type", 
                "Cannot determine project type for RPC generation", "RPC", 
                DiagnosticSeverity.Warning, true)));
            return;
    }
}
```

### 3. Отдельные методы генерации

#### GenerateServerCode
- Генерирует только TargetClientRpcSender
- Использует namespace KarpikEngineServer.Generated
- Создает файл TargetClientRpcSender.g.cs

#### GenerateClientCode  
- Генерирует только TargetClientRpcDispatcher
- Использует namespace KarpikEngineClient.Generated
- Создает файл TargetClientRpcDispatcher.g.cs

## Структура генерируемых файлов

### Сервер (TargetClientRpcSender.g.cs)
```csharp
// <auto-generated/>
using LiteNetLib;
using LiteNetLib.Utils;
using Network;

namespace KarpikEngineServer.Generated
{
    public class TargetClientRpcSender
    {
        private static ThreadLocal<TargetClientRpcSender> _instance = 
            new ThreadLocal<TargetClientRpcSender>(() => new TargetClientRpcSender());
        public static TargetClientRpcSender Instance => _instance.Value;
        
        private readonly NetDataWriter _writer = new NetDataWriter();
        
        // TargetRpc методы
        public void ShowMessage(NetPeer targetPeer, ShowMessageTargetRpc cmd) { ... }
        
        // ClientRpc методы  
        public void PlayerJoined(NetPeer targetPeer, PlayerJoinedClientRpc cmd) { ... }
        public void PlayerJoinedAll(NetManager netManager, PlayerJoinedClientRpc cmd) { ... }
    }
}
```

### Клиент (TargetClientRpcDispatcher.g.cs)
```csharp
// <auto-generated/>
using LiteNetLib.Utils;
using Karpik.Engine.Shared;

namespace KarpikEngineClient.Generated
{
    public class TargetClientRpcDispatcher
    {
        public void Dispatch(NetDataReader reader)
        {
            var commandId = reader.GetUShort();
            switch (commandId)
            {
                case 15: // ShowMessageTargetRpc
                {
                    var cmd = new ShowMessageTargetRpc();
                    cmd.message = reader.GetString();
                    cmd.duration = reader.GetFloat();
                    Worlds.Instance.EventWorld.SendEvent(cmd);
                    break;
                }
                // ... другие команды
            }
        }
    }
}
```

## Синхронизация ID команд

### Проблема
Поскольку генераторы работают в разных проектах, CommandIdManager может присваивать разные ID одним и тем же командам.

### Решение
1. **Детерминированная генерация ID**: Использовать хеш от полного имени команды
2. **Сортировка команд**: Обрабатывать команды в алфавитном порядке
3. **Префиксы**: Использовать префиксы "TargetRpc." и "ClientRpc." для уникальности

```csharp
private uint GenerateDeterministicId(string commandFullName, string prefix)
{
    var key = $"{prefix}{commandFullName}";
    var hash = key.GetHashCode();
    return (uint)(Math.Abs(hash) % 65535) + 1; // Избегаем 0 и больших чисел
}
```

## Интеграция с существующей системой

### CommandIdManager изменения
```csharp
public static class CommandIdManager
{
    // Добавляем детерминированную генерацию
    public static uint GetDeterministicId(string fullName)
    {
        if (_assignedIds.TryGetValue(fullName, out var existingId))
            return existingId;
            
        var hash = fullName.GetHashCode();
        var id = (uint)(Math.Abs(hash) % 65535) + 1;
        _assignedIds[fullName] = id;
        return id;
    }
}
```

## Диаграмма потока данных

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Shared Project │    │ Server Project  │    │ Client Project  │
│                 │    │                 │    │                 │
│ RPC Commands    │───▶│ RpcGenerator    │    │ RpcGenerator    │
│ (Structures)    │    │                 │    │                 │
│                 │    │ Generates:      │    │ Generates:      │
│                 │    │ - Sender only   │    │ - Dispatcher    │
│                 │    │                 │    │   only          │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │ Server Runtime  │    │ Client Runtime  │
                       │                 │    │                 │
                       │ - Send RPC      │───▶│ - Receive RPC   │
                       │ - No Dispatch   │    │ - No Send       │
                       │   code          │    │   code          │
                       └─────────────────┘    └─────────────────┘
```

## Преимущества дизайна

1. **Безопасность**: Клиент не может отправлять RPC, сервер не обрабатывает входящие RPC
2. **Размер сборки**: Каждый проект содержит только необходимый код
3. **Ясность**: Четкое разделение ответственности
4. **Производительность**: Меньше кода для компиляции и выполнения
5. **Отладка**: Легче понять что происходит в каждом проекте

## Риски и митигация

### Риск: Рассинхронизация ID команд
**Митигация**: Использование детерминированной генерации ID на основе хеша имени команды

### Риск: Сложность отладки
**Митигация**: Добавление подробных комментариев в генерируемый код с указанием ID команд

### Риск: Обратная совместимость
**Митигация**: Сохранение существующих API и постепенная миграция

## План реализации

1. Создать ProjectTypeDetector
2. Модифицировать TargetClientRpcGenerator для условной генерации
3. Разделить методы генерации на GenerateServerCode и GenerateClientCode
4. Обновить CommandIdManager для детерминированной генерации ID
5. Создать тесты для проверки синхронизации ID
6. Обновить документацию