using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Network.Codegen;

[Generator]
public class NetworkGenerator : IIncrementalGenerator
{
    private const string NetworkedComponentAttributeName = "Network.NetworkedComponentAttribute";
    private const string NetworkedFieldAttributeName = "Network.NetworkedFieldAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Найти все структуры, помеченные нашим атрибутом
        IncrementalValuesProvider<StructDeclarationSyntax> structDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is StructDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)!;

        // 2. Собрать информацию о структурах и их полях
        IncrementalValueProvider<(Compilation, ImmutableArray<StructDeclarationSyntax>)> compilationAndStructs
            = context.CompilationProvider.Combine(structDeclarations.Collect());

        // 3. Сгенерировать код
        context.RegisterSourceOutput(compilationAndStructs,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static StructDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var structDeclaration = (StructDeclarationSyntax)context.Node;
        foreach (var attributeList in structDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is IMethodSymbol attributeSymbol)
                {
                    if (attributeSymbol.ContainingType.ToDisplayString() == NetworkedComponentAttributeName)
                    {
                        return structDeclaration;
                    }
                }
            }
        }
        return null;
    }
    
    private static void Execute(Compilation compilation, ImmutableArray<StructDeclarationSyntax> structs, SourceProductionContext context)
    {
        if (structs.IsDefaultOrEmpty)
        {
            return;
        }

        var structsToGenerate = GetStructsToGenerate(compilation, structs, context.CancellationToken);
        if (structsToGenerate.Count == 0)
        {
            return;
        }

        string sourceCode = GenerateSource(structsToGenerate);
        context.AddSource("NetworkManager.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static List<StructToGenerate> GetStructsToGenerate(Compilation compilation, ImmutableArray<StructDeclarationSyntax> structs, CancellationToken cancellationToken)
    {
        var result = new List<StructToGenerate>();
        foreach (var structDecl in structs)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var semanticModel = compilation.GetSemanticModel(structDecl.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(structDecl) is ITypeSymbol structSymbol)
            {
                var fields = new List<FieldToGenerate>();
                foreach (var member in structSymbol.GetMembers())
                {
                    if (member is IFieldSymbol field && field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == NetworkedFieldAttributeName))
                    {
                        fields.Add(new FieldToGenerate(field.Name, field.Type.ToDisplayString()));
                    }
                }
                result.Add(new StructToGenerate(structSymbol.Name, structSymbol.ToDisplayString(), fields));
            }
        }
        return result;
    }

    private static string GenerateSource(List<StructToGenerate> structsToGenerate)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using DCFApixels.DragonECS;");
        sb.AppendLine("using LiteNetLib;");
        sb.AppendLine("using LiteNetLib.Utils;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using DCFApixels.DragonECS;");
        sb.AppendLine("using Network;");
        sb.AppendLine();
        sb.AppendLine("namespace Game.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    public class NetworkManager");
        sb.AppendLine("    {");
        
        sb.AppendLine("        private interface IComponentSerializer");
        sb.AppendLine("        {");
        sb.AppendLine("            void Write(NetDataWriter writer, object component);");
        sb.AppendLine("            void ReadAndApply(EcsWorld world, int entityId, NetDataReader reader);");
        sb.AppendLine("            void ClearPool(EcsWorld world);");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        sb.AppendLine("        private class Aspect : EcsAspect");
        sb.AppendLine("        {");
        sb.AppendLine("            public EcsPool<NetworkId> networkId = Inc;");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Словарь-регистратор
        sb.AppendLine("        private readonly Dictionary<long, IComponentSerializer> _serializers = new();");
        sb.AppendLine("        private readonly Dictionary<int, int> _networkIdToEntityId = new();");
        sb.AppendLine("        private readonly Dictionary<int, int> _entityIdToNetworkId = new();");
        sb.AppendLine();

        // Метод Register
        sb.AppendLine("        public void Register()");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_serializers.Count > 0) return;");
        long id = 1;
        foreach (var s in structsToGenerate)
        {
            sb.AppendLine($"            _serializers.Add({id}, new {s.Name}Serializer());");
            id++;
        }
        sb.AppendLine("        }");
        sb.AppendLine();

        // Метод WriteSnapshot
        sb.AppendLine("        public void WriteSnapshot(EcsWorld world, NetDataWriter writer, List<int> destroyedNetIds)");
        sb.AppendLine("        {");
        sb.AppendLine("            writer.Put(destroyedNetIds.Count);");
        sb.AppendLine("            foreach (var entityId in destroyedNetIds)");
        sb.AppendLine("            {");
        sb.AppendLine("                writer.Put(entityId);");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            var networkedEntities = world.Where(out Aspect a);");
        sb.AppendLine("            writer.Put(networkedEntities.Count);");
        sb.AppendLine("            foreach (var entityId in networkedEntities)");
        sb.AppendLine("            {");
        sb.AppendLine("                writer.Put(a.networkId.Get(entityId).Id);");
        id = 1;
        foreach (var s in structsToGenerate)
        {
            sb.AppendLine($"                var pool_{id} = world.GetPool<{s.FullName}>();");
            sb.AppendLine($"                bool has_{id} = pool_{id}.Has(entityId);");
            sb.AppendLine($"                writer.Put(has_{id});");
            sb.AppendLine($"                if (has_{id}) _serializers[{id}].Write(writer, pool_{id}.Get(entityId));");
            id++;
        }
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Метод ApplySnapshot
        sb.AppendLine("        public void ApplySnapshot(EcsWorld world, NetDataReader reader)");
        sb.AppendLine("        {");
        sb.AppendLine("            int destroyedCount = reader.GetInt();");
        sb.AppendLine("            for (int i = 0; i < destroyedCount; i++)");
        sb.AppendLine("            {");
        sb.AppendLine("                int netId = reader.GetInt();");
        sb.AppendLine("                if (_networkIdToEntityId.TryGetValue(netId, out int entityToDestroy))");
        sb.AppendLine("                {");
        sb.AppendLine("                    var entity = world.GetEntityLong(entityToDestroy);");
        sb.AppendLine("                    if(entity.IsAlive) world.DelEntity(entityToDestroy);");
        sb.AppendLine("                    _networkIdToEntityId.Remove(netId);");
        sb.AppendLine("                    _entityIdToNetworkId.Remove(entityToDestroy);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            int entityCount = reader.GetInt();");
        sb.AppendLine("            var netIdPool = world.GetPool<NetworkId>();");
        sb.AppendLine("            for (int i = 0; i < entityCount; i++)");
        sb.AppendLine("            {");
        sb.AppendLine("                int netId = reader.GetInt();");
        sb.AppendLine("                if (!_networkIdToEntityId.TryGetValue(netId, out int localEntityId))");
        sb.AppendLine("                {");
        sb.AppendLine("                    localEntityId = world.NewEntity();");
        sb.AppendLine("                    netIdPool.Add(localEntityId).Id = netId;");
        sb.AppendLine("                    _networkIdToEntityId[netId] = localEntityId;");
        sb.AppendLine("                    _entityIdToNetworkId[localEntityId] = netId;");
        sb.AppendLine("                }");
        sb.AppendLine();
        id = 1;
        foreach (var s in structsToGenerate)
        {
            sb.AppendLine($"                bool has_{id} = reader.GetBool();");
            sb.AppendLine($"                if (has_{id}) _serializers[(short){id}].ReadAndApply(world, localEntityId, reader);");
            sb.AppendLine($"                else world.GetPool<{s.FullName}>().TryDel(localEntityId);");
            id++;
        }
        sb.AppendLine("            }");
        sb.AppendLine("        }");

        foreach (var s in structsToGenerate)
        {
            sb.AppendLine($"        private class {s.Name}Serializer : IComponentSerializer");
            sb.AppendLine("        {");
            // Write
            sb.AppendLine($"            public void Write(NetDataWriter writer, object componentObj){{ var component = ({s.FullName})componentObj;");
            foreach (var field in s.Fields)
            {
                sb.AppendLine($"                writer.Put(component.{field.Name});");
            }
            sb.AppendLine("            }");
            // ReadAndApply
            sb.AppendLine($"            public void ReadAndApply(EcsWorld world, int entityId, NetDataReader reader) {{ ref var component = ref world.GetPool<{s.FullName}>().TryAddOrGet(entityId);");
            foreach (var field in s.Fields)
            {
                sb.AppendLine($"                component.{field.Name} = reader.Get{GetReaderMethod(field.TypeName)}();");
            }
            sb.AppendLine("            }");
            // ClearPool
            sb.AppendLine($"            public void ClearPool(EcsWorld world) {{ world.GetPool<{s.FullName}>().ClearAll(); }}");
            sb.AppendLine("        }");
        }

        sb.AppendLine("        public void ClearClientCache()");
        sb.AppendLine("        {");
        sb.AppendLine("            _networkIdToEntityId.Clear();");
        sb.AppendLine("            _entityIdToNetworkId.Clear();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetReaderMethod(string typeName)
    {
        return typeName switch
        {
            "float" or "System.Single" => "Float",
            "int" or "System.Int32" => "Int",
            "bool" or "System.Boolean" => "Bool",
            "double"  or "System.Double" => "Double",
            "entlong" => "entlong",
            _ => typeName // Add other types if needed
        };
    }
}

// Вспомогательные классы для хранения информации о коде
internal record FieldToGenerate(string Name, string TypeName)
{
    public string Name { get; } = Name;
    public string TypeName { get; } = TypeName;
}

internal record StructToGenerate(string Name, string FullName, List<FieldToGenerate> Fields)
{
    public string Name { get; } = Name;
    public string FullName { get; } = FullName;
    public List<FieldToGenerate> Fields { get; } = Fields;
}