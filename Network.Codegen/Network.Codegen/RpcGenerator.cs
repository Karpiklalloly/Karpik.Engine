using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Network.Codegen;

[Generator]
public class RpcGenerator : IIncrementalGenerator
{
    private const string EventCommandInterfaceName = "Network.IEventCommand";
    private const string StateCommandInterfaceName = "Network.IStateCommand";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Мы больше не можем полагаться только на SyntaxProvider.
        // Нам нужна вся компиляция целиком.
        IncrementalValueProvider<Compilation> compilationProvider = context.CompilationProvider;

        // Регистрируем один колбэк, который будет делать всю работу.
        context.RegisterSourceOutput(compilationProvider, Execute);
    }

    private void Execute(SourceProductionContext context, Compilation compilation)
    {
        // Сбрасываем глобальный коллектор команд в начале компиляции
        GlobalCommandCollector.Reset();
        
        var rpc = new StringBuilder();
        rpc.Append(GenerateStartRpc());

        var dispatcher = new StringBuilder();
        dispatcher.Append(GenerateDispatcherStart());
        
        var allCommandNames = new List<string>();

        // 1. Найти все структуры, реализующие IEventCommand, во всех сборках
        var eventCommandInfos = FindAllEventCommandInfos(compilation, context.CancellationToken);
        if (eventCommandInfos.Any())
        {
            rpc.Append(GenerateClientRpc(eventCommandInfos));
            dispatcher.Append(GenerateServerDispatcher(eventCommandInfos));
            allCommandNames.AddRange(eventCommandInfos.Select(c => c.FullName));
        }

        var stateCommandInfos = FindAllStateCommandInfos(compilation, context.CancellationToken);
        if (stateCommandInfos.Any())
        {
            rpc.Append(GenerateClientRpc(stateCommandInfos));
            context.AddSource("CommandRequests.g.cs", SourceText.From(GenerateRequests(stateCommandInfos), Encoding.UTF8));
            dispatcher.Append(GenerateServerDispatcher(stateCommandInfos));
            allCommandNames.AddRange(stateCommandInfos.Select(c => c.FullName));
        }

        rpc.Append(GenerateEndRpc());
        context.AddSource("Rpc.g.cs", SourceText.From(rpc.ToString(), Encoding.UTF8));

        dispatcher.Append(GenerateDispatcherEnd());
        context.AddSource("ServerCommandDispatcher.g.cs", SourceText.From(dispatcher.ToString(), Encoding.UTF8));

        // Добавляем команды в глобальный коллектор
        GlobalCommandCollector.AddCommands(allCommandNames);
        
        // Генерируем отладочную информацию только если это последний генератор
        // (определяем по наличию StateCommand - они есть только в RpcGenerator)
        if (stateCommandInfos.Any())
        {
            var allCollectedCommands = GlobalCommandCollector.GetAllCommandsAndFinalize();
            CommandIdDebugger.GenerateDebugInfo(context, allCollectedCommands);
            CommandIdDebugger.ValidateCommandIds(context, allCollectedCommands);
        }
    }

    private string GenerateRequests(List<CommandInfo> commandInfos)
    {
        //Debugger.Launch();
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Karpik.Engine.Shared;");
        sb.AppendLine("using Network;");
        sb.AppendLine("using LiteNetLib;");
        sb.AppendLine("using LiteNetLib.Utils;");
        sb.AppendLine("using Karpik.Engine.Shared.DragonECS;");
        sb.AppendLine("");
        foreach (var command in commandInfos)
        {
            sb.AppendLine("public struct " + command.Name + "Request : IEcsComponentRequest");
            sb.AppendLine("{");
            foreach (var field in command.Fields.Where(field => field.Name != "Target" && field.Name != "Source"))
            {
                sb.AppendLine($"    public {field.TypeName} {field.Name};");
            }
            sb.AppendLine($"    public int Target {{ get; set; }}");
            sb.AppendLine($"    public IEnumerable<int> Sources {{ get; set; }}");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    // --- МЕТОДЫ СБОРА ИНФОРМАЦИИ ---

    private List<CommandInfo> FindAllEventCommandInfos(Compilation compilation, CancellationToken ct)
    {
        var commandInterface = compilation.GetTypeByMetadataName(EventCommandInterfaceName);
        if (commandInterface == null)
        {
            return new List<CommandInfo>();
        }

        var commandInfos = new List<CommandInfo>();

        // Проходим по всем сборкам, включая текущую
        var allAssemblies = new[] { compilation.Assembly }.Concat(compilation.SourceModule.ReferencedAssemblySymbols);

        foreach (var assembly in allAssemblies)
        {
            // Рекурсивно обходим все пространства имен и типы
            ProcessNamespace(assembly.GlobalNamespace, commandInterface, commandInfos, ct);
        }

        // Сортируем и присваиваем ID через CommandIdManager
        commandInfos = commandInfos.OrderBy(c => c.FullName).ToList();
        for (int i = 0; i < commandInfos.Count; i++)
        {
            var id = CommandIdManager.GetOrAssignId(commandInfos[i].FullName);
            commandInfos[i] = commandInfos[i] with { Id = id };
        }

        return commandInfos;
    }

    private List<CommandInfo> FindAllStateCommandInfos(Compilation compilation, CancellationToken ct)
    {
        var commandInterface = compilation.GetTypeByMetadataName(StateCommandInterfaceName);
        if (commandInterface == null)
        {
            return new List<CommandInfo>();
        }

        var commandInfos = new List<CommandInfo>();

        // Проходим по всем сборкам, включая текущую
        var allAssemblies = new[] { compilation.Assembly }.Concat(compilation.SourceModule.ReferencedAssemblySymbols);

        foreach (var assembly in allAssemblies)
        {
            // Рекурсивно обходим все пространства имен и типы
            ProcessNamespace(assembly.GlobalNamespace, commandInterface, commandInfos, ct);
        }

        // Сортируем и присваиваем ID через CommandIdManager
        commandInfos = commandInfos.OrderBy(c => c.FullName).ToList();
        for (int i = 0; i < commandInfos.Count; i++)
        {
            var id = CommandIdManager.GetOrAssignId(commandInfos[i].FullName);
            commandInfos[i] = commandInfos[i] with { Id = id };
        }

        return commandInfos;
    }

    private void ProcessNamespace(INamespaceSymbol namespaceSymbol, INamedTypeSymbol commandInterface, List<CommandInfo> commandInfos, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        foreach (var typeMember in namespaceSymbol.GetTypeMembers())
        {
            if (typeMember.TypeKind == TypeKind.Struct && typeMember.AllInterfaces.Contains(commandInterface, SymbolEqualityComparer.Default))
            {
                var fields = typeMember.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(f => !f.IsStatic && f.CanBeReferencedByName)// && f.AssociatedSymbol == null) // Игнорируем backing fields для свойств
                    .Select(f => new FieldInfo(f.Name, f.Type.ToDisplayString(), false))
                    .ToList();
                var properties = typeMember.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(f => !f.IsStatic && f.CanBeReferencedByName)
                    .Select(f => new FieldInfo(f.Name, f.Type.ToDisplayString(), true))
                    .ToList();
                fields = fields.Concat(properties).ToList();
                commandInfos.Add(new CommandInfo(0, typeMember.Name, typeMember.ToDisplayString(), fields));
            }
        }

        foreach (var nestedNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            ProcessNamespace(nestedNamespace, commandInterface, commandInfos, ct);
        }
    }

    // --- Методы генерации кода ---

    private static string GenerateStartRpc()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Karpik.Engine.Shared;");
        sb.AppendLine("using Network;");
        sb.AppendLine("using LiteNetLib;");
        sb.AppendLine("using LiteNetLib.Utils;");
        sb.AppendLine("using DCFApixels.DragonECS;");
        sb.AppendLine();
        sb.AppendLine("namespace Game.Generated.Client");
        sb.AppendLine("{");
        sb.AppendLine("    public class Rpc");
        sb.AppendLine("    {");
        sb.AppendLine("        [Inject] private NetManager _netManager;");
        sb.AppendLine("        [Inject] private EcsEventWorld _eventWorld;");
        sb.AppendLine("        private readonly NetDataWriter _writer = new NetDataWriter();");
        sb.AppendLine();
        sb.AppendLine("        private void Send(DeliveryMethod deliveryMethod)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_netManager?.FirstPeer != null && _netManager.FirstPeer.ConnectionState == ConnectionState.Connected)");
        sb.AppendLine("            {");
        sb.AppendLine("                 _netManager.FirstPeer.Send(_writer, deliveryMethod);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        return sb.ToString();
    }

    private static string GenerateEndRpc()
    {
        var sb = new StringBuilder();
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateClientRpc(List<CommandInfo> commands)
    {
        var sb = new StringBuilder();

        foreach (var cmd in commands)
        {
            var paramName = cmd.Name.Replace("Command", "").ToLower();
            sb.AppendLine($"        public void {cmd.Name.Replace("Command", "")}({cmd.FullName} {paramName}, DeliveryMethod deliveryMethod = DeliveryMethod.ReliableOrdered)");
            sb.AppendLine("        {");
            sb.AppendLine("            _writer.Reset();");
            sb.AppendLine("            _writer.Put((byte)PacketType.Command);");
            sb.AppendLine($"            _writer.Put((ushort){cmd.Id});");
            foreach (var field in cmd.Fields)
            {
                sb.AppendLine($"            _writer.Put({paramName}.{field.Name});");
            }
            sb.AppendLine("            Send(deliveryMethod);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateServerDispatcher(List<CommandInfo> commands)
    {
        var commandMap = commands.ToDictionary(c => c.FullName);

        return GenerateCommandDispatcher(commandMap);
    }

    private static string GenerateDispatcherStart()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Karpik.Engine.Shared;");
        sb.AppendLine("using LiteNetLib.Utils;");
        sb.AppendLine("using Network;");
        sb.AppendLine("using Karpik.Engine.Shared.DragonECS;");
        sb.AppendLine("using DCFApixels.DragonECS;");
        sb.AppendLine();
        sb.AppendLine("namespace Game.Generated.Server");
        sb.AppendLine("{");

        sb.AppendLine($"    public partial class CommandDispatcher");
        sb.AppendLine("    {");
        sb.AppendLine("        [Inject] private EcsEventWorld _eventWorld;");
        sb.AppendLine();
        sb.AppendLine("        public void Dispatch(int playerEntity, NetDataReader reader)");
        sb.AppendLine("        {");
        sb.AppendLine("            var commandId = reader.GetUShort();");
        sb.AppendLine("            switch (commandId)");
        sb.AppendLine("            {");
        return sb.ToString();
    }

    private static string GenerateDispatcherEnd()
    {
        var sb = new StringBuilder();
        sb.AppendLine("                default:");
        sb.AppendLine("                    // Unknown command ID");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateCommandDispatcher(Dictionary<string, CommandInfo> commandMap)
    {
        var sb = new StringBuilder();

        foreach (var pair in commandMap)
        {
            var cmdInfo = pair.Value;

            sb.AppendLine($"                case {cmdInfo.Id}: // {cmdInfo.Name}");
            sb.AppendLine("                {");
            sb.AppendLine($"                    var cmd = new {cmdInfo.FullName}();");
            foreach (var field in cmdInfo.Fields)
            {
                sb.AppendLine($"                    cmd.{field.Name} = reader.Get{GetReaderMethod(field.TypeName)}();");
            }
            sb.AppendLine($"                    _eventWorld.SendEvent(cmd);");
            sb.AppendLine("                    break;");
            sb.AppendLine("                }");
        }

        return sb.ToString();
    }

    private static string GetReaderMethod(string typeName)
    {
        return typeName switch
        {
            "float" or "System.Single" => "Float",
            "int" or "System.Int32" => "Int",
            "bool" or "System.Boolean" => "Bool",
            "uint" or "System.UInt32" => "UInt",
            "ushort" or "System.UInt16" => "UShort",
            "byte" or "System.Byte" => "Byte",
            _ => typeName.Split('.').Last()
        };
    }
}
